{% extends "common/cpp_file_base.jinja" %}
{% import "vaf_interface/macros.jinja" as interface with context %}

{% block includes %}
#include <chrono>
#include <cstdlib>
#include <google/protobuf/serial_arena.h>

#include "vaf/error_domain.h"
#include "vaf/future.h"
#include "vaf/internal/promise.h"
#include "protobuf/interface/{{ module.ModuleInterfaceRef.Namespace.replace("::","/").lower()}}/{{module.ModuleInterfaceRef.Name.lower()}}/protobuf_transformer.h"
{% endblock %}

{% block content %}
{{ module.Name }}::{{ module.Name }}(::vaf::Executor& executor, vaf::String name, ::vaf::ExecutableControllerInterface& executable_controller_interface)
  : ::vaf::ControlInterface(std::move(name), {}, executable_controller_interface, executor),
    executor_{ControlInterface::executor_} {
}

::vaf::Result<void> {{ module.Name }}::Init() noexcept {
  return ::vaf::Result<void>{};
}

void {{ module.Name }}::Start() noexcept {
  const char* value = std::getenv("SILKIT_REGISTRY_URI");
  const auto registry_uri = (value != nullptr) ? std::string(value) : "silkit://localhost:8501";

  const std::string participant_config_text = R"(
  Description: My participant configuration
  Logging:
      Sinks:
      - Type: Stdout
        Level: Info
  )";
  auto config = SilKit::Config::ParticipantConfigurationFromString(participant_config_text);
  {% set participant_name = add_namespace_to_name(module.Name, module.Namespace) %}
  participant_ = SilKit::CreateParticipant(config, "{{ participant_name }}", registry_uri);

  {% for de in module.ModuleInterfaceRef.DataElements %}
  {% set data_type = data_type_to_str(de.TypeRef) %}
  {% if module.ModuleInterfaceRef.Namespace != "" %}
  {% set de_name = module.ModuleInterfaceRef.Namespace + "::" + de.Name %}
  {% else %}
  {% set de_name = de.Name %}
  {% endif %}
  SilKit::Services::PubSub::PubSubSpec pubsubspec_{{ de_name.replace("::","_") }}{"{{ module.ModuleInterfaceRef.Name }}_{{ de.Name }}", "application/protobuf"};
  pubsubspec_{{ de_name.replace("::","_") }}.AddLabel("Instance", "{{ silkit_instance }}", {{ "SilKit::Services::MatchingLabel::Kind::Mandatory" if silkit_instance_is_optional in [False] else "SilKit::Services::MatchingLabel::Kind::Optional" }});
  {% if silkit_namespace is not none %}
  pubsubspec_{{ de_name.replace("::","_") }}.AddLabel("Namespace", "{{ silkit_namespace }}", {{ "SilKit::Services::MatchingLabel::Kind::Mandatory" if silkit_namespace_is_optional in [False] else "SilKit::Services::MatchingLabel::Kind::Optional" }});
  {% endif %}
  auto receptionHandler_{{ de_name.replace("::","_") }} = [&](auto* subscriber, const auto& dataMessageEvent) {
    const std::lock_guard<std::mutex> lock(cached_{{ de_name.replace("::","_") }}_mutex_);

    std::unique_ptr< {{ data_type }} > ptr;
    protobuf::interface::{{ module.ModuleInterfaceRef.Namespace }}::{{ module.ModuleInterfaceRef.Name }}::{{ de.Name }}  deserialized;
    deserialized.ParseFromArray( dataMessageEvent.data.data(), dataMessageEvent.data.size() );
    ptr = std::make_unique< {{ data_type }} >();
    ::protobuf::interface::{{ module.ModuleInterfaceRef.Namespace}}::{{ module.ModuleInterfaceRef.Name}}::{{ de.Name }}ProtoToVaf(deserialized,*ptr);
    this->cached_{{ de_name.replace("::","_") }}_ = vaf::ConstDataPtr<const {{ data_type }}>{std::move(ptr)};

    for(auto& handler_container : registered_{{ de_name.replace("::","_") }}_event_handlers_) {
      if(handler_container.is_active_) {
        handler_container.handler_(cached_{{ de_name.replace("::","_") }}_);
      }
    }
  };
  subscriber_{{ de_name.replace("::","_") }}_= participant_->CreateDataSubscriber("Subscriber_{{ de_name.replace("::","_") }}", pubsubspec_{{ de_name.replace("::","_") }}, receptionHandler_{{ de_name.replace("::","_") }});

  {% endfor %}

  {% for op in module.ModuleInterfaceRef.Operations %}
  {% if module.ModuleInterfaceRef.Namespace != "" %}
  {% set op_name = module.ModuleInterfaceRef.Namespace + "::" + op.Name %}
  {% else %}
  {% set op_name = op.Name %}
  {% endif %}
  SilKit::Services::Rpc::RpcSpec rpcspec_{{ op_name.replace("::","_") }}{"{{ module.ModuleInterfaceRef.Name }}_{{ op.Name }}", "application/protobuf"};
  rpcspec_{{ op_name.replace("::","_") }}.AddLabel("Instance", "{{ silkit_instance }}", {{ "SilKit::Services::MatchingLabel::Kind::Mandatory" if silkit_instance_is_optional in [False] else "SilKit::Services::MatchingLabel::Kind::Optional" }});
  {% if silkit_namespace is not none %}
  rpcspec_{{ op_name.replace("::","_") }}.AddLabel("Namespace", "{{ silkit_namespace }}", {{ "SilKit::Services::MatchingLabel::Kind::Mandatory" if silkit_namespace_is_optional in [False] else "SilKit::Services::MatchingLabel::Kind::Optional" }});
  {% endif %}
  auto ReturnFunc_{{ op_name.replace("::","_") }} = [&](auto* /*client*/, const auto& event) {
    ::vaf::internal::Promise<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}>*
        promise_pointer = static_cast<
          ::vaf::internal::Promise<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}>*>(
            event.userContext);
    if (event.callStatus == SilKit::Services::Rpc::RpcCallStatus::Success) {
      {% if op.has_any_parameter_out_inout %}
      {% set return_type = operation_get_return_type(op, module.ModuleInterfaceRef) %}
      {{ return_type }} output;
      protobuf::interface::{{ module.ModuleInterfaceRef.Namespace }}::{{ module.ModuleInterfaceRef.Name }}::{{ op.Name }}_out deserialized;
      deserialized.ParseFromArray( event.resultData.data(), event.resultData.size() );
      {% if op.has_any_parameter_out_inout %}
      ::protobuf::interface::{{ module.ModuleInterfaceRef.Namespace }}::{{ module.ModuleInterfaceRef.Name }}::{{ op.Name }}OutProtoToVaf(deserialized, output);
      {% endif%}
      promise_pointer->set_value(output);
      {% else %}
      promise_pointer->set_value();
      {% endif %}
    } else {
      vaf::Error error_code{::vaf::ErrorCode::kNotOk, "Rpc call failed"};
      vaf::internal::SetVafErrorCodeToPromise(*promise_pointer, error_code);
    }
    delete promise_pointer;
  };
  rpc_client_{{ op_name.replace("::","_") }}_= participant_->CreateRpcClient("{{ op_name.replace("::","_") }}", rpcspec_{{ op_name.replace("::","_") }}, ReturnFunc_{{ op_name.replace("::","_") }});

  {% endfor %}
  ReportOperational();
}

void {{ module.Name }}::Stop() noexcept {
}

void {{ module.Name }}::DeInit() noexcept {
}

void {{ module.Name }}::StartEventHandlerForModule(const vaf::String& module) {
  {% for de in module.ModuleInterfaceRef.DataElements %}
  {% set de_name = add_namespace_to_name(de.Name, module.ModuleInterfaceRef.Namespace) %}
  for(auto& handler_container : registered_{{ de_name }}_event_handlers_) {
    if(handler_container.owner_ == module) {
      handler_container.is_active_ = true;
    }
  }
  {% endfor %}
  active_modules_.push_back(module);
}

void {{ module.Name }}::StopEventHandlerForModule(const vaf::String& module) {
  {% for de in module.ModuleInterfaceRef.DataElements %}
  {% set de_name = add_namespace_to_name(de.Name, module.ModuleInterfaceRef.Namespace) %}
  for(auto& handler_container : registered_{{ de_name }}_event_handlers_) {
    if(handler_container.owner_ == module) {
      handler_container.is_active_ = false;
    }
  }
  {% endfor %}
  active_modules_.erase(std::remove(active_modules_.begin(), active_modules_.end(), module));
}

{% for de in module.ModuleInterfaceRef.DataElements %}
{% set data_type = data_type_to_str(de.TypeRef) %}
{% set de_name = add_namespace_to_name(de.Name, module.ModuleInterfaceRef.Namespace) %}

{{ interface.consumer_data_element_get_allocated(de, module.Name ) }} {
  ::vaf::Result<::vaf::ConstDataPtr<const {{ data_type }}>> result_value{
      ::vaf::Error{::vaf::ErrorCode::kNotOk, "No sample available"}};
  const std::lock_guard<std::mutex> lock(cached_{{ de_name }}_mutex_);
  if (cached_{{ de_name }}_) {
    result_value = ::vaf::Result<::vaf::ConstDataPtr<const {{ data_type }}>>{cached_{{ de_name }}_};
  }
  return result_value;
}

{{ interface.consumer_data_element_get(de, module.Name ) }} {
  {{ data_type }} return_value{};
  const std::lock_guard<std::mutex> lock(cached_{{ de_name }}_mutex_);
  if (cached_{{ de_name }}_) {
    return_value = *cached_{{ de_name }}_;
  }
  return return_value;
}

{{ interface.consumer_data_element_handler(de, module.Name ) }} {
  registered_{{ de_name }}_event_handlers_.emplace_back(owner, std::move(f));
  if(std::find(active_modules_.begin(), active_modules_.end(), owner) != active_modules_.end()) {
    registered_{{ de_name }}_event_handlers_.back().is_active_ = true;
  }
}

{% endfor %}


{% for op in module.ModuleInterfaceRef.Operations %}
{% if module.ModuleInterfaceRef.Namespace != "" %}
{% set op_name = module.ModuleInterfaceRef.Namespace + "::" + op.Name %}
{% else %}
{% set op_name = op.Name %}
{% endif %}
{{ interface.consumer_operation(op, module.ModuleInterfaceRef, module.Name) }} {
  ::vaf::Future<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}> return_value;
  ::vaf::internal::Promise<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}>* promise_pointer =
                  new ::vaf::internal::Promise<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}>();
  return_value = ::vaf::internal::CreateVafFutureFromVafPromise<{{ operation_get_return_type(op, module.ModuleInterfaceRef) }}>(*promise_pointer);
  protobuf::interface::{{ module.ModuleInterfaceRef.Namespace }}::{{ module.ModuleInterfaceRef.Name }}::{{ op.Name }}_in request;
{% if op.has_any_parameter_in_inout %}
  protobuf::interface::{{ module.ModuleInterfaceRef.Namespace }}::{{ module.ModuleInterfaceRef.Name }}::{{ op.Name }}InVafToProto({{ get_in_parameter_list_comma_separated(op) }}, request);
{% endif %}
  size_t nbytes = request.ByteSizeLong();
  std::vector<std::uint8_t> serialized(nbytes);
  if (nbytes != 0u) {
    request.SerializeToArray(serialized.data(), nbytes);
  }
  rpc_client_{{ op_name.replace("::","_") }}_->Call(serialized, promise_pointer);

  return return_value;
}
{% endfor %}
{% endblock %}
